
const MODEL_PATH = 'modelo/model.json';
let aiModel = null;
let modelLoaded = false;
let usingSimulation = false;

const CLASSES = {
    0: 'Ascaris',
    1: 'Giardia', 
    2: 'Hookworm',
    3: 'Trichuris',
    4: 'Negative'
};

async function initApp() {
    console.log("üß™ Iniciando Detector - DIAGN√ìSTICO EXTENDIDO");
    await loadAIModel();
    setupEventListeners();
}

async function loadAIModel() {
    console.log("üîÑ CARGANDO MODELO - DIAGN√ìSTICO EXTENDIDO");
    updateUIStatus('loading', '0%');
    
    try {
        // 1. Verificar TensorFlow.js
        if (typeof tf === 'undefined') {
            throw new Error('TensorFlow.js no est√° cargado');
        }
        console.log("‚úÖ TensorFlow.js cargado, versi√≥n:", tf.version.tfjs);
        
        // 2. Verificar acceso al modelo
        console.log("üîç Verificando modelo en:", MODEL_PATH);
        const response = await fetch(MODEL_PATH);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status} - No se puede acceder al modelo`);
        }
        
        // 3. Analizar la estructura del model.json
        const modelData = await response.json();
        console.log("üìã ANALIZANDO ESTRUCTURA DEL MODELO:");
        console.log("- Format:", modelData.format);
        console.log("- Generated by:", modelData.generatedBy);
        
        if (modelData.modelTopology) {
            const topology = modelData.modelTopology;
            console.log("- Tiene modelTopology: ‚úÖ");
            
            // Buscar la primera capa
            let firstLayer = null;
            if (topology.model_config && topology.model_config.layers) {
                firstLayer = topology.model_config.layers[0];
                console.log("- Estructura: modelTopology ‚Üí model_config ‚Üí layers");
            } else if (topology.config && topology.config.layers) {
                firstLayer = topology.config.layers[0];
                console.log("- Estructura: modelTopology ‚Üí config ‚Üí layers");
            }
            
            if (firstLayer) {
                console.log("- Primera capa:", firstLayer.class_name, "-", firstLayer.name);
                if (firstLayer.config) {
                    console.log("- batch_input_shape:", firstLayer.config.batch_input_shape);
                    console.log("- dtype:", firstLayer.config.dtype);
                } else {
                    console.log("‚ùå Primera capa NO tiene config");
                }
            } else {
                console.log("‚ùå No se pudo encontrar la primera capa");
            }
        } else {
            console.log("‚ùå NO tiene modelTopology");
        }
        
        // 4. Cargar el modelo
        console.log("üì• Cargando modelo con tf.loadLayersModel...");
        aiModel = await tf.loadLayersModel(MODEL_PATH, {
            onProgress: (fraction) => {
                const percent = Math.round(fraction * 100);
                updateUIStatus('loading', percent + '%');
            }
        });
        
        console.log("üéâ ¬°MODELO CARGADO EXITOSAMENTE!");
        console.log("üìê Inputs:", aiModel.inputs);
        console.log("üì§ Outputs:", aiModel.outputs);
        
        if (aiModel.inputs && aiModel.inputs[0]) {
            console.log("‚úÖ Input shape:", aiModel.inputs[0].shape);
        }
        
        // 5. Precalentar
        await warmUpModel();
        
        modelLoaded = true;
        usingSimulation = false;
        console.log("üöÄ IA REAL ACTIVADA - MODO SIMULACI√ìN DESACTIVADO");
        updateUIStatus('ready');
        
    } catch (error) {
        console.error('üí• ERROR CR√çTICO:', error);
        console.error('üí• Mensaje completo:', error.message);
        await enableSimulationMode();
    }
}

async function warmUpModel() {
    try {
        console.log("üî• Precalentando modelo...");
        const warmUpTensor = tf.zeros([1, 224, 224, 3]);
        const prediction = await aiModel.predict(warmUpTensor);
        console.log("‚úÖ Precalentamiento exitoso");
        warmUpTensor.dispose();
        prediction.dispose();
    } catch (error) {
        console.warn("‚ö†Ô∏è Error en precalentamiento:", error);
    }
}

async function enableSimulationMode() {
    console.warn("üé≠ ACTIVANDO MODO SIMULACI√ìN");
    modelLoaded = false;
    usingSimulation = true;
    updateUIStatus('simulation');
}

async function processImage(imageFile) {
    if (!modelLoaded && !usingSimulation) return;
    
    updateUIStatus('processing');
    
    try {
        let results;
        if (usingSimulation) {
            results = await simulatePrediction();
        } else {
            results = await predictWithAI(imageFile);
        }
        displayResults(results);
        updateUIStatus('ready');
    } catch (error) {
        console.error('Error procesando imagen:', error);
        updateUIStatus('error');
    }
}

async function predictWithAI(imageFile) {
    const imageTensor = await loadAndProcessImage(imageFile);
    
    try {
        const prediction = aiModel.predict(imageTensor);
        const results = await prediction.data();
        const processedResults = processPredictionResults(results);
        imageTensor.dispose();
        prediction.dispose();
        return processedResults;
    } catch (error) {
        imageTensor.dispose();
        throw error;
    }
}

async function loadAndProcessImage(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = async function(e) {
            const img = new Image();
            img.onload = async function() {
                let tensor = tf.browser.fromPixels(img)
                    .resizeNearestNeighbor([224, 224])
                    .toFloat()
                    .expandDims(0)
                    .div(255.0);
                resolve(tensor);
            };
            img.onerror = () => reject(new Error('Error imagen'));
            img.src = e.target.result;
        };
        reader.onerror = () => reject(new Error('Error archivo'));
        reader.readAsDataURL(file);
    });
}

function processPredictionResults(results) {
    const scores = Array.from(results);
    const maxScore = Math.max(...scores);
    const predictedClass = scores.indexOf(maxScore);
    
    return {
        predictedClass: predictedClass,
        className: CLASSES[predictedClass],
        confidence: (maxScore * 100).toFixed(2),
        scores: scores,
        timestamp: new Date().toLocaleString()
    };
}

async function simulatePrediction() {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const randomScores = Array(5).fill(0).map(() => Math.random());
    const total = randomScores.reduce((a, b) => a + b, 0);
    const normalizedScores = randomScores.map(score => score / total);
    const maxScore = Math.max(...normalizedScores);
    const predictedClass = normalizedScores.indexOf(maxScore);
    
    return {
        predictedClass: predictedClass,
        className: CLASSES[predictedClass],
        confidence: (maxScore * 100).toFixed(2),
        scores: normalizedScores,
        timestamp: new Date().toLocaleString(),
        simulation: true
    };
}

function displayResults(results) {
    const resultsDiv = document.getElementById('results');
    if (!resultsDiv) return;
    
    let html = '<div class="result-card">';
    html += '<h3>üîç RESULTADO DEL AN√ÅLISIS</h3>';
    html += '<div class="prediction">üéØ <strong>Par√°sito Detectado:</strong> ' + results.className + '</div>';
    html += '<div class="confidence">üìà <strong>Confianza:</strong> ' + results.confidence + '%</div>';
    
    if (results.simulation) {
        html += '<div class="simulation-warning">‚ö†Ô∏è MODO SIMULACI√ìN - DATOS DE PRUEBA</div>';
    } else {
        html += '<div class="real-ai-indicator" style="color: green; font-weight: bold;">‚úÖ AN√ÅLISIS CON IA REAL</div>';
    }
    
    html += '<div class="timestamp">üïê ' + results.timestamp + '</div>';
    html += '</div>';
    
    resultsDiv.innerHTML = html;
}

function updateUIStatus(status, data = null) {
    const statusElement = document.getElementById('model-status');
    if (!statusElement) return;
    
    const messages = {
        'loading': 'üîÑ ' + (data || 'Cargando IA...'),
        'ready': '‚úÖ IA REAL ACTIVA - Sistema listo',
        'simulation': 'üé≠ MODO SIMULACI√ìN - IA no disponible',
        'processing': 'üî¨ Analizando...',
        'error': '‚ùå Error'
    };
    
    statusElement.textContent = messages[status] || 'Estado';
}

function setupEventListeners() {
    const uploadInput = document.getElementById('image-upload');
    const uploadArea = document.getElementById('upload-area');
    
    if (uploadInput && uploadArea) {
        uploadInput.addEventListener('change', function(e) {
            if (e.target.files.length > 0) {
                processImage(e.target.files[0]);
            }
        });
        
        uploadArea.addEventListener('click', () => uploadInput.click());
    }
}

document.addEventListener('DOMContentLoaded', initApp);
